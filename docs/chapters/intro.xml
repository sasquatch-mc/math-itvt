<?xml version="1.0"?>
                 
<chapter id="intro">
    <title>Кратък увод</title>
    
    <sect2>
        <title>Какво е Tulipa?</title>
        
        <para>
            Tulipa е <ulink url="http://framework.zend.com">Zend Framework</ulink> базирана платформа за разработка на уеб системи, която спазва <ulink url="http://framework.zend.com/manual/en/coding-standard.html">стандартите на Zend Framework</ulink>
        </para>
        <para>
            Tulipa е разработена от Йоан-Александър Григоров през лятото на 2010 г. Информация за лиценза на проекта може да прочетете във файла LICENSE.
        </para>
        
    </sect2>
    
    <sect2>
        <title>За какво ми е Tulipa?</title>
        
        <para>
            <ulink url="http://framework.zend.com">Zend Framework</ulink> е един доста "освободен" фреймуърк. Като казвам "освободен", имам предвид, че не ви ограничава в някакви рамки на разработка. Естествено, Zend Framework си има своите строги правила, но нека да приемем че те са за да не правим <emphasis role="bold">глупости</emphasis> с него.
        </para>
        
        <para>
            Това качество прави ZF толкова професионален. Но за разлика от другите фреймуърци като Yii, CakePHP, CodeIgniter., Zend не е толкова "автоматизиран".
            Ако искаме да напишем една обикновенна система - например малък блог, бихме се справили много по-бързо и лесно с някой фреймуърк от рода на Yii. Zend Framework е проектиран така, че да бъде гъвкав, но не и да ви предоставя уеб система почти на готово. В това отношение Zend не е толкова <ulink url="http://en.wikipedia.org/wiki/Rapid_application_development">RAD</ulink> фреймуърк.
        </para>
        
        <para>
            Когато седнете да пишете сайт на Zend, трябва да помислите предварително за доста неща, което ще ви забавят.
        </para>
        
        <para>
            Например контрола за достъп в сайта: Zend_Acl е страхотен компонент, но няма вградена поддръжка за работа с бази данни, за това трябва да си го напишете сам.
        </para>
        
        <para>
            Друг пример е че за разлика от Yii, CakePHP или CodeIgniter, Zend е почти "ням" относно моделите(което всъщност е добре, по-долу ще разберете защо). 
            В CakePHP например всеки модел е свързан с таблица в база данни и са налице 4-те основни операции с данни(CRUD - Create-Read-Update-Delete).
        </para>
        
        <para>
            В документацията на ZF никъде (освен в Quick Start) не се споменава за моделите. Всъщност това е умишлено. Голямата грешка на почти всеки фреймуърк (CakePHP, Yii, CodeIgniter) е че имат много грешна имплементация на моделите. И сега ще разбуля духовете като заявя, че всъщност <emphasis role="bold">модела не е задължилно да бъде свързан с таблица в базата данни</emphasis> и това повтарям е най-голямото недоразумение при MVC фреймуърците.
        </para>

        <para>
            Моделът трябва да съдържа логиката на дадена подсистема. Например сайтът ни е мултиезичен и имаме контролер LangController и екшън change, който сменя езика. Заедно към тази подсистема ние имаме и моделът Application_Model_Language. Най-често срещаната грешка е да пренебрегнем модела и да пишем логика в контролера директно. Повечето разработчици (които пишат на CodeIgniter например) ще извадят от базата данни информацията за искания език(файл с дефиниции, иконка на езика и т.н.) и дотук с модела! Тази информация после бива обработвана в контролера директно. Правилният начин това да се случи е да създадем метод changeLanguage($languageName) в Application_Model_Language и вътре в него да напишем цялата логика за смяна на езика. 
        </para>
        
        <para>
            Предимствата на този подход са:
            <itemizedlist numeration="lowerroman">
                <listitem>
                    <para>Не натоварваме контролера с логика. Запомнете че в контролера почти никога не си пише логика! Контролера служи само за да се поемат или изпратят данни, обработката им се извършва в модела!</para>
                </listitem>
                <listitem>
                    <para>Имаме достъп до логиката за смяна на език. Ако искаме да сменим езика в някакви по-различни обстоятелства и не от контролера LangController можем лесно да извикаме Application_Model_Language::changeLanguage($languageName)</para>
                </listitem>
                <listitem>
                    <para>В бъдеще можем да променяме кода вътре в метода changeLanguage(), а интерфейса си остава същия</para>
                </listitem>
            </itemizedlist>
        </para>
        
        <para>
        Но въпреки това, е хубаво да имаме някои фундаментални функционалности при работа с моделите. В Tulipa ще намерите абстрактният клас Application_Model_Abstract който предоставя API с най-фундаменталните операции, включително Data Mapper инициализация, translate() метод за мултиезичност(Zend_Translate), url() метод (пряк пък до Zend_View_Helper_Url) и т.н.
        </para>
        
        <para>
            <emphasis>Ситуацията с моделите е нищожна част от всичките допълнения на Tulipa. Нататък ще разберете повече.</emphasis>
        </para>
        
    </sect2>
 
</chapter>
